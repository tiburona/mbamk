#!/usr/bin/env python3

""" According to the FreeSurfer license posted online at https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferSoftwareLicense,
    I, or anyone, is granted the right to make derivative works from the FreeSurfer software avilable from
    https://github.com/freesurfer/freesurfer so long as the original license and copyright are communicated.
    In lieu of pasting the full text of that license into this file, the URL above communicates that license.
    
    This particular code is a derivative of Ruopeng Wang's C++ FSSurface code for the purposes
    of converting binary pial surface files, generated by FreeSurfer, to 3D object files.
    
    To the extent allowed by the above-mentioned license, this code can be merged into the FreeSurfer project
    if desired by the FreeSurfer team, or released to the public domain, insofar as the prior license is respected.
    
    Mike Schmidt, 11/04/2019
"""


import argparse
import os
import sys
import struct


""" Support functions to extract portions of the binary file """

def get_header_magic_number(data, pos):
    """ From binary data, return a 3-byte int and a cursor position after reading it. """
    
    magic_numbers = struct.unpack("BBB", data[pos:3])
    magic_number = magic_numbers[0] * 256 * 256
    magic_number += magic_numbers[1] * 256
    magic_number += magic_numbers[2]
    return magic_number, pos + 3
    

def get_creation_string(data, pos):
    """ From binary data, return a string of all sequential characters from cursor, and the new cursor position. """
    
    chars = []
    in_string = True
    n = pos
    while(True):
        try:
            c = struct.unpack("c", data[n:n + 1])[0].decode("utf-8")
            if in_string and c != "\n":
                chars.append(c)
            elif c == "\n":
                in_string = False
            else:
                # Our string is done.
                # Cycle through \n characters then quit, even if the byte can be interpreted as a char.
                if c != "\n":
                    raise ValueError
        except (ValueError, UnicodeDecodeError):
            # Eventually, this is the preferred exit point. The cursor is beyond the creation string.
            return "".join(chars), n
        n += 1
    
    # This should never happen, but is here to be syntactically correct.
    return "".join(chars), n
    
    
def get_4byte_int(data, pos):
    """ Read 4 bytes as an unsigned integer (big-endian);
        return the integer and new cursor position. """
    
    return struct.unpack(">I", data[pos: pos + 4])[0], pos + 4
        
        
def get_4byte_float(data, pos):
    """ Read 4 bytes as an float (big-endian);
        return the float and new cursor position. """
    
    return struct.unpack(">f", data[pos: pos + 4])[0], pos + 4
        
        
def get_vertex(data, pos):
    """ Read 3 4-byte floats, return them as a tuple, and new cursor position. """
    
    x, pos = get_4byte_float(data, pos)
    y, pos = get_4byte_float(data, pos)
    z, pos = get_4byte_float(data, pos)
    return (x, y, z), pos
        
        
def get_face(data, pos):
    """ Read 3 4-byte ints, return them as a tuple, and new cursor position. """
    
    x, pos = get_4byte_int(data, pos)
    y, pos = get_4byte_int(data, pos)
    z, pos = get_4byte_int(data, pos)
    return (x, y, z), pos
        
        
def read_pial(pial_file_name):
    """ Read the binary data contained in f and return it as a dataframe. """
    
    with open(pial_file_name, "rb") as handle:
        pial_data = handle.read()
        
    # The pial files have a header before the data.
    cursor = 0
    magic_number, cursor = get_header_magic_number(pial_data, cursor)
    if magic_number != 16777214:
        print("{} does not look like surface data.".format(pial_file_name))
        print("Its first 3 signature bytes hold uint {:,}.".format(magic_number))
        sys.exit(1)
    print("Magic number from {}: {:,}".format(pial_file_name, magic_number))
    
    creation_string, cursor = get_creation_string(pial_data, cursor)
    print("Creation String: {}".format(creation_string))
    
    num_vertices, cursor = get_4byte_int(pial_data, cursor)
    num_faces, cursor = get_4byte_int(pial_data, cursor)
    print("{} contains {:,} vertices and {:,} faces.".format(pial_file_name, num_vertices, num_faces))
    
    vertices = []
    for i in range(num_vertices):
        vertex, cursor = get_vertex(pial_data, cursor)
        vertices.append(vertex)
    print("Read {:,} vertices.".format(len(vertices)))
    
    faces = []
    for i in range(num_faces):
        face, cursor = get_face(pial_data, cursor)
        faces.append(face)
    print("Read {:,} faces.".format(len(faces)))
    
    return vertices, faces
    

def write_obj(v_list, f_list, obj_file):
    """ Write the dataframe out to obj format. """
    
    with open(obj_file, "w") as handle:
        for v in v_list:
            handle.write("v {:f} {:f} {:f}\n".format(*v))
        for f in f_list:
            handle.write("f {:d} {:d} {:d}\n".format(
                f[0] + 1, f[1] + 1, f[2] + 1
            ))


def main():
    """ Entry point """
    
    parser = argparse.ArgumentParser()
    parser.add_argument("input_file")
    parser.add_argument("output_file")
    args = parser.parse_args()
    
    if not os.path.isfile(args.input_file):
        print("{} does not exist.")
        sys.exit(1)
    
    input_vertices, input_faces = read_pial(args.input_file)
    write_obj(input_vertices, input_faces, args.output_file)
    

if __name__ == '__main__':
    main()
